<html><body>
                  <h1>cel:flow</h1>
          <p>moves the cel, but 1 or more intermediate states can be injected by the flow callback.</p>
          <p><code><pre>      acel:flow(flowfunction, x, y, w, h[, update[, finalize]])
      acel:flow(flowname, x, y, w, h[, update[, finalize]])
    </pre></code></p>
          <div class="arguments">
          <h2>arguments</h2>
          <ul><li>
            <span>cel</span> <span>self</span> <span>self</span>
          </li><li>
            <span>callback</span> <span>flowfunction</span> <span>        a function that produces intermediate states
                  <p></p>
          <p><code><pre>            flowfunction(context, ox, x, oy, y, ow, w, oh, h)
            flowfunction(context, ox, x, oy, y, ow, w, oh, h)
          </pre></code></p>
          <div class="arguments">
          <h2>arguments</h2>
          <ul><li>
            <span>table</span> <span>context</span> <span>        
         <ul>Storage for flow life-cycle data.  The context can also be used by the flowfunction to
                store data.  The context is included in the drawtable of a cel, until the flow is finalized.<li>iteration - The number of times the flowfunction has been called, initially 1,
                  incremented by 1 when the flowfuction returns</li><li>duration - The number of milliseconds since the flow was started, initially 0,
                  reset when the flow function returs</li><li>finalize - initially -1, when the flow is about to be finalized this is set to
                  context.iteration</li></ul> </span>
          </li><li>
            <span>number</span> <span>x</span> <span>x position when flow started.</span>
          </li><li>
            <span>number</span> <span>fx</span> <span>x position when flow ends.</span>
          </li><li>
            <span>number</span> <span>y</span> <span>y position when flow started.</span>
          </li><li>
            <span>number</span> <span>fy</span> <span>y position when flow ends.</span>
          </li><li>
            <span>number</span> <span>w</span> <span>w dimension when flow started.</span>
          </li><li>
            <span>number</span> <span>fw</span> <span>w dimension when flow ends.</span>
          </li><li>
            <span>number</span> <span>h</span> <span>h dimension when flow started.</span>
          </li><li>
            <span>number</span> <span>fh</span> <span>h dimension when flow is ends.</span>
          </li></ul>
          </div>
        
          <div class="arguments">
          <h2>returns</h2>
          <ul><li>
            <span>number</span> <span>x</span> <span>intermediate x position.</span>
          </li><li>
            <span>number</span> <span>y</span> <span>intermediate y position.</span>
          </li><li>
            <span>number</span> <span>w</span> <span>intermediate width.</span>
          </li><li>
            <span>number</span> <span>h</span> <span>intermediate height.</span>
          </li><li>
            <span>boolean</span> <span>continue</span> <span>true if the flow is incomplete, if not true this signals the end of the flow.</span>
          </li></ul>
          </div>
        
        </span>
          </li><li>
            <span>any</span> <span>flowname</span> <span>a key to a flowfunction defined in the cel's face.  (self:getface().flow[flowname]) </span>
          </li><li>
            <span>number</span> <span>x</span> <span>new x position of self relative to host. Defaults to self.x if nil</span>
          </li><li>
            <span>number</span> <span>y</span> <span>new y position of self relative to host. Defaults to self.y if nil</span>
          </li><li>
            <span>number</span> <span>w</span> <span>new width of self. Defaults to self.w if nil</span>
          </li><li>
            <span>number</span> <span>h</span> <span>new height of self. Defautls to self.h if nil</span>
          </li><li>
            <span>callback</span> <span>update</span> <span>        called to move the cel to a new position.  Defaults to cel.move if nil.
                  <p></p>
          <p><code><pre>            update(self, x, y, w, h)
          </pre></code></p>
          <div class="arguments">
          <h2>arguments</h2>
          <ul><li>
            <span>cel</span> <span>self</span> <span>self (same self from cel:flow)</span>
          </li><li>
            <span>number</span> <span>x</span> <span>new x position of self.</span>
          </li><li>
            <span>number</span> <span>y</span> <span>new y position of self.</span>
          </li><li>
            <span>number</span> <span>w</span> <span>new width of self.</span>
          </li><li>
            <span>number</span> <span>h</span> <span>new height of self.</span>
          </li></ul>
          </div>
        
          
        </span>
          </li><li>
            <span>callback</span> <span>finalize</span> <span>        called when the flow has completed --TODO describe what completed means.
                  <p></p>
          <p><code><pre>            finalize(self)
          </pre></code></p>
          <div class="arguments">
          <h2>arguments</h2>
          <ul><li>
            <span>cel</span> <span>self</span> <span>self (same self from cel:flow)</span>
          </li></ul>
          </div>
        
          
        </span>
          </li></ul>
          </div>
        
          <div class="arguments">
          <h2>returns</h2>
          <ul><li>
            <span>cel</span> <span>self</span> <span>self</span>
          </li></ul>
          </div>
        
            <h2>notes</h2>
    <p><p>    If flowfunction is nil or flowname does not have an entry in self:getface().flow then update is called with the 
    final position followed by a call to finalize.  So acel:flow(nil, x, y, w, h) has the same effect as 
    acel:move(x, y, w, h).
    </p><p>    When a flow starts the flowfunction is called to get its initial position which is passed to update().  Thereafter
    flowfunction/update are called when the cel driver moves cel.timer() forward.
    </p></p>
        <h2>examples</h2>
    <p><p><code><pre>    local cel = require 'cel'
    local host = ...

    local button = cel.button.new(100, 100):link(host, 'center'):relink()

    local function lerp(a, b, p)
      return a + p * (b -a)
    end

    local duration = 1000

    local function linearflow(context, ox, x, oy, y, ow, w, oh, h)
      if context.duration >= duration then return x, y, w, h end
      local dt = context.duration/duration
      x = lerp(ox, x, dt)
      y = lerp(oy, y, dt) 
      w = lerp(ow, w, dt)
      h = lerp(oh, h, dt)
      return x, y, w, h, true
    end
    
    function button:onclick()
      local toggle = button.onclick
      local x, y, w, h = button:pget('x', 'y', 'w', 'h')
      function button:onclick()
        self:flow(linearflow, x, y, w, h)
        button.onclick = toggle
      end
      self:flow(linearflow, 
                math.random(0, 200),
                math.random(0, 200),
                math.random(50, 200),
                math.random(50, 200))
    end

    </pre></code></p></p>
    
      </body></html>