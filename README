
Cel is free software: it may be used for any purpose, including commercial purposes, at absolutely no cost.
Cel is licensed under the terms of the MIT license

Copyright (C) 2011 by Matthew W. Burk

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
--]]


Introduction

A cel ([c]ontrol [el]ement) is the basic unit or building block of the Cel library. To use the libarry effectively you must understand what a cel is as well as what it can and can't do. A cel is the equivalent of a widget. A cel aggregates user input events, and will normally be rendered to the screen.

the cel rectangle

A cel is a rectangle cel.x is the left of the rectangle, cel.y is the top, cel.w is the width and cel.h is the height. The orgin of a cels coordinate system is at the top left corner of the cel, x increases to the right and y increases down. The right of a cel is cel.x + cel.w, and the bottom is cel.y + cel.h. A cel contains all points where x >= 0 and x < cel.w and y >=0 and y < cel.h. This set can be restricted but not increased.

hosts and links

All cels are containers. This means that any cel (with the exception of the root cel) can be put into any other cel. Furthermore the contaier/containee relationship is fully dynamic and can be changed easily. This heirarchy or cel tree starts with the root cel (obvious, i know). Often this root cel would be called a parent, and the cels that it contains would be called its children. This is not the terminology used by Cel because parent/child implies that the parent creates the child and that the relationship is fixed. To highlight that the relationship is mutable the parent is called the host and the child a link (because it is linked to the host). When reading the documentation, up the cel tree means towards the root of the tree. From here on out the terms host and link will be used.

composite cels

A composite cel is a cel that is composed from other cels. The host cel is called the composite cel and any cels that are created by it are called component cels. The created distinction is important, a cel that is linked to the composite cel is not considered a component cel if it was not created by the composite cel. Typically a composite cel will encapsulate its component cels.

Goals - the requirements that shaped the Cel library

Cels design is influenced by these requirements:

Embeddability

The prime requirement of Cel is it should be embeddable. Meaning embedding Cel in a host process that uses it and controls it. This implies that the requirements for a suitable host should be minimal. This requirement is why Cel is passive, the host process always tells Cel when and how to act. Cel also does not render anything, nor does it define a pattern for rendering, rendering is the job of the host process.
Easy to use

This is just a bit less important than the prime requirement. Easy to use is the whole point of an api in the first place (well at least for a high-level api like Cel). My view is that there are endless ways to achieve the same result, an api is a path to that result. Adding features can make an api easier to use or harder to use, most of the time a feature will make some things easier and some harder. Makeing those decisions is the art of api programming, there is no formula.
Easy to use means different things depending on the type of user. Cel is targeted to three types of users:

The platform(like Love) programmer who has all the basic ingredients for a gui, such as mouse and keyboard input, and rendering capabilites. There are literrally hundreds of these platforms, each custom made and lovingly crafted. Many of them have primitive gui support (becuase its more work than it seems). I want them all to use Cel, and I want Cel to be a natural fit for their platform so that they want to use it. This means providing what they don't have, and not what they do, which is why Cel does not render.
The gui programmer. This could be a programmer using a platform or the platform programmer. If these guys don't like Cel, then the platform programmer will not want to offer it. This programmer is the true test of the api, and most of the api design favors making this user happy, sometimes at the cost of the platform programmer.
The user interacting with gui. This means full featured controls, for example a scrollbar that works as expected, not a watered down shell of what we are all familiar with using.
Speed

All of the requirements have priority over speed. I'm not saying speed is not important, it is very important but a high-level api is the antithesis of speed. Speed is the easiest goal to achieve, simply reduce features and/or write it in assembly. The job of an api is to make good tradeoffs between execution speed and ease of use. Obviously what ends up on the screen can be done another way with a different set of tradeoffs.

Sandboxing

TODO

Derived Requirements

These requirements are aimed at making Cel easy to use without breaking the prime requirement of embedability.

No special cases

There should be no special cases or special cels that are allowed to break the rules. Special cases really just leads to special cases gone wild, which leads to ???, which leads to suffering. This is an ideal, but alas the root cel is special becuase it cannot link or be unlinked.

Text metrics and display

Cel should have halfway decent text output, meaning support for basic font metrics. Ideally it would just give you beautiful font rendering (becuase its not fun or easy to roll your own). Unfortunately I could not achieve this becuase it would be a large hurdle to embedability. Cel, instead, attempts to ease the burden of dealing with text.

Automatic layout

Automatic layout is a requirement, that I originally assumed would not be. After all, what could be easier that settting x,y,width,height for a rectangle, right? Well I tried that, then I tried to make a demo, and the simplest things (like a list of textbuttons equal width and height) were just too hard to do. I had to make sure i knew the longest string I wanted to display and if those strings changed, i had to react someway. This was all part of the demo, I was adding automatic layout in the demo app itself to work around these problems. This was one of those times I had to admit defeat and admit automatic layout is a requirement for 'easy to use'.

I was not thrilled with automatic layout in any gui library I had used before, if the layout was flexible it wasn't easy, if it was easy it was not flexible. Cel has automatic layout built into every cel, and you will use it without even realizeing it.

A mutable cel tree

The primary functions to enable this are cel:link() and cel:unlink(). If you have a cel, linking it to another cel is always ok, and 'just works', and the same goes for unlinking. Having to manage when you can and cannot do this and what cels go with what other cels would be a nightmare, worse than memory management. So Cel doesn't require that you do, and to enable this encapsulation is necessary.

Encapsulation

A cel has many properties that are not exposed outside of the core library, these are considered implementation details in some cases, but it is mostly done so that things 'just work'. Any derived cel can use the same techniques that Cel uses to achieve encapsulation.

The cel tree cannot be queried or walked. This means there is no way to get the host of a cel or get the links of a cel. There is no method that exposes a cel that the application did not create. This means there is no way to get the cel with focus, or under the mouse etc. You may think that it is too restrictive, but the effect is the opposite. Putting a window in a listbox, or an editbox in a listbox or a label in a listbox are all identical operations, and this is largely enabled by encapsulation.

Cel doesn't actively enforce encapsulation, but it does enable it by not exposing cels. Cel does not expose cels is becuase the cel tree is mutable (which is highly desireable). Here is an partial list of intentionally ommited functionality:

cel:gethost()
cel:getlinks()
cel.getcelwithfocus()
cel.getcelatxy(x,y)
cel.getbyid(id)
A composite cel should be able to assert full control of the layout and lifecycle of its component cels. The ability to peek into or walk the cel tree means creating a composite cel is too hard, and the end result will be too fragile. To illustrate the problem I'll use the window cel. A window has a handle to drag the window around with, this handle is actually another cel that the window encapsulates. What can a window do to ensure that this cel is not unlinked? One option would be to set a property on the cel and prevent unlinking if this property is set, but that solution is a hack and would lead to uncertainty and an endless number of special cases. If I as the gui programmer unlink a cel, I expect it to happen, period. Cel enables encapsulation so that you can hide cels you need full control of. The functionality lost by this encapsulation is regained through the link() and relink() functions. For example how does one add a button to the window handle, if you can't link to it? Enabling that type of functionality is what guided the desing of the link(), relink() and __link(). How does one alter the properties of the handle, for instance its size, appearance, etc? Enabling that type of functionality is what initially guided the design of cel faces.

Separation of concerns

When creating a gui the look is very important. Specifying the functionality of a cel, and how the app reacts to events is a concern that is largely orthogonal to how the cel looks. Defining this separation is especially important to Cel because it has no rendering capabilites. Cel enables this separation through cel faces. A face is the context available to the renderer and is associated to a cel at creation. Besides seperating functionality from appearance this has several other advantages.

To illustrate I will show the bad, but not uncommon way this is done in many gui libraries. This is the bad way:


    button = cel.button.new(10, 10)
    button.setcolor('blue')
    button.setbordersize(2)
    button.setactivatecolor('green')
  
Identifying a cel semantically is better:

    button = cel.button.new(10, 10, 'invetory button')
  
Why is the bad way bad?
The most common scenario is a bunch of buttons will look the same, they will have the same colors or images etc. Repeating this for each identical looking button is just noise. This puts the burden on the app programmer to create specialized generators, or overly long constructors to prevent repeating themselves.
Its an unecessary waste of space, storing the same information for each button. There is no workaround to fix this issue.
It ends up being too hard to change, and enforcing a common theme is an added task for the app programmer.
It presents a barrier to simultaneous work, as in artist/programmer working independently
The better way addresses all of these problems. One recently popular way to do this is to copy html/css type of functionality. There is certainly wisdom and good design happening there, but a gui does not occupy the same space as html, it doesn't have an abundance of content, and layout is often an integral part of the functionality of the gui. Cel faces have some similarity to this model, but is targeted to the needs of a typical gui, not a document.

Reuse through inheritance

Composition inheritance has already been discussed, that is what a composite cel is. Composition inheritance is best, but sometimes implementation inheritance is useful. Cel does support implementation inheritance, but it should not be your first choice when creating a new type of cel. The main reason is that implementation inheritance is too fragile and some people view it as an is-a relationship which is only sometimes true. A hallmark of implementation inheritance is overriding existing methods, this is also where you will get into trouble if you are not very careful. Adding to the implementation without overriding is much less fragile, but you can get that through composition. So implementation inheritance is really only useful for overriding or indicating the is-a relationship (but overriding can turn the is-a relationship off imo). To override a function or property(in a way the parent did not anticipate) using implementation inheritance requires knowledge of the internal workings of the parent. It works well in a cohesive pacakge, or when you already have a full understanding of the parent implementation details.

How can overriding change the is-a relationship you ask? Well changing a defining characteristic will do it imo. A Cel label has the characteristic that it can't be touched, as if it is etched into its host cel. If I overrode that behavior, and let it be touched the new cel is no longer a label, becuase it is not a drop in replacement for a label in every circumstance. The built-in Cel controls do exactly this kind of overriding, do not make the assumption that the is-a relationship is true just because implementation inheritance is used. The relationship will be stated in the documentation. By convention is-a cel will be true for any type of cel.

If implementation inheritance is so bad what does Cel use it? The reason is because its useful, the code reuse is real, and you can expose a private interface to the inheriting cel. Through alternate interface you can enable more dangerous but useful functions. They can be more dangerous becuase there use can be segregated. A cel could be created that does something wrong, that has erratic behavior, or crashes, etc. Simple solution don't use it, or maybe even fix it in that one place. If these useful but dangerous functions were exposed to any instance of any cel the problem becomes much bigger. What makes a function dangerous? Well there is no formula for that, sorry.

Cel takes a pragmatic approach to this. Use the public interface and its easy going, use the private interface and you are trusted and take on a higher level of responsibility. The private interface is a part of the metacel. The Cel documentation will instruct you on how it expects this interface to be used. Deviating from those expectaions is not advised.

metacels

A metacel is used to define a new type of cel.  A metacel defines a function to create a cel, and has a more privledged position in the Cel library than a cel.  A new metacel is created with cel.newmetacel('name') where name is the name of the new metacel.  A new metacel is a copy of an existing metacel.  The cel metacel defines these functions:
metacel:new(...) to create a new cel.
metacel:compile() to create a new cel from a table definition.
metacel:newmetacel() to copy this metacel.
metacel:newfactory() to create a factory for the metacel, which allows cel to be created without exposing the metacel.
metacel:getface() to resolve a face for this metacel.
metacel:setlimits() to set the minimum and maximum dimensions of a cel.
The cel metacel defines these behavior altering methods
metacel:__link() to react when a link is made and change how or where the link is made.
metacel:__relink() to react when a link is relinked.
metacel:__unlink() to react when a link is unlinked
metacel:__resize() to react when a cel is resized
metacel:__linkmove() to react when a link moves.
metacel:__describe() to describe the cel for rendering.
A metacel can define an event callback function for all of the standard events, and will always receive events before the cel.

A new metacel aslo has a new copy of a metatable stored at metacel.metatable.  This metatable is the metatable shared by all cels created though metacel:new().  The metatable is the public interface of the cel. The cel metatable defines these functions:
cel:link() to link the cel to a host cel.
cel:relink() to change the link relationship.
cel:unlink() to unlink from a host cel.
cel:raise(), cel:sink() to change cels z order.
cel:disable() to make the cel unresponsive to user input.
cel:enable() to make the cel responsive to user input.
cel:pget() to get properties of the cel by name.
cel:getface() to get the face of the cel.
cel:move(), cel:moveby(), cel:resize() to mutate the cel rectangle.
cel:takefocus(), cel:hasfocus() to manage user focus.
cel:islinkedto(), cel:islinkedtoroot().
cel:trapmouse(), cel:hasmousetrapped(), cel:freemouse().
cel:flow*() to animate the cel.
These functions should not be overridden, and in a future release this may be enforced through a proxy or userdata.

The metacel should be kept private, the recommended way to do this is with a module.  The dominate pattern used in Cel to define a new metacel is this:

local cel = require 'cel'
local metacel, metatable = cel.newmetacel('foo')

--do this for each new public function
function metatable:myfunc(a, b, c)
    --self is the cel
end

--define event callbacks on the metacel
function metacel:onmousedown(foo, button, x, y, intercepted)
    --do somthing
    return true
end

--add to description
function metacel:__describe(t)
    t.fooproperty = 'a foo property'
end

do
  local _new = metacel.new
  function metacel:new(w, h, face)
    --ensure we have a valid face for the metacel
    face = self:getface(face)  
    local foo = _new(self, w, h, face)
    --do foo setup
    return foo
  end

  local _compile = metacel.compile
  function metacel:compile(t, foo)
    foo = foo or metacel:new(t.w, t.h, t.face)   
    return _compile(self, t, foo)
  end
end

return metacel:newfactory()

When Cel is put on a new platform, it may be convenient to define a metcel that is platform specific, such as an image cel.
faces

A cel face is a context for the renderer to store information that it needs to render a cel. A single face can be shared by multiple cels or a cel can have its own unique face. In most cases though you would have a face that is used for buttons, another for listboxes, another for labels and so on.

This is how you create a face:
local blueface = cel.face {
  metacel = 'cel',
  name = 'blue',
}

Cel associates a face to a metacel based on the name of the metacel.  The face in the example is for the 'cel' metacel, which all other metacels are derived from.  Calling cel.face with a table definition will first look for a face with the metacel and name specified.  If an existing face is not found then it is created.   All other entries in the table definition copied to the face.  The face is a table with a protected metatable managed by Cel.  What goes in the face is determined by the platform Cel is embedded in, I am going to use colors for illustrative purposes.  Adding a color to a face is easy.

This method finds the existinng face and add the new field to it:
cel.face {
  metacel = 'cel',
  name = 'blue',
  color = cel.color.rgb(0, 0, 1),
}

This method writes to the face directly:
blueface.linecolor = cel.color.rgb(0, 0, 0)

At this point blueface has an entry for fillcolor and linecolor. 

If you want to remove any entry from a face, this will not work:
cel.face {
  metacel = 'cel',
  name = 'blue',
  color = cel.color.rgb(0, 0, 1),
  linecolor = nil,
}

To remove it you must do this:
blueface.linecolor = nil.

Now when we see a face in the description our renderer can get the color from the face and use that when rendering the cel. An important point is that Cel does not care what the color is, nor does it understand the meaning of the color entry in the face, this definition is something that your renderer and app understand. There are some entries that cel does understand, and defines the meaning of. These entries are reserved by Cel:
font - if present this should be a font returned from cel.loadfont()
layout - if present this should be a table describing the layout of the cel, each metacel will define its own layout if any.
flow - if present this should be a table of flow functions, the metacel will define the names to use and what they mean.
An face name is not required, an unamed face is identified only by the metacel, and is called the metacel face.  The metacel face can be accessed like this:
local celface = cel.face {
  metacel = 'cel',
  --notice a name is not specified
  draw = function(face, description) 
    local color = face.color or cel.color.rgb(1, 1, 1)   
    fillrect(description.x, description.y, description.w, description.h, color)
  end
}

We just a defined draw function in the cel metacel face (fillrect is a hypothetical function).  It looks for a color in the face and uses that color when drawing the cel rectangle.
If a named face does not have an entry then the metacel face is checked. In other words any entries in the metacel face are also availabe to named faces (via __index metamethod). 

This defines a face for a button. The metacel = 'button' entry is what makes it a button face.
local buttonface = cel.face {
  metacel = 'button',
  bordercolor = cel.color.rgb(1, 1, 1),
}

Because a button is a cel, the button metacel face will also inherit from the cel metacel face, and a named button face will inherit from the button metacel.  This means that buttonface.draw == celface.draw.
Of course a button will not normally look like a flat cel, so you should give the button metacel its own draw function, this draw function can use the extra information a button provides in its description and
any extra information from a button face.

function buttonface:draw(t)
  --self is the face, t is the button description
  local color = self.color
  fillrect(t.x, t.y, t.w, t.h, color)
  local bordercolor = self.bordercolor
  strokerect(t.x, t.y, t.w, t.h, bordercolor) 
end

If a button is created like this: local button = cel.button.new(100, 100) then it will use the unnamed face for the button metacel. To create a button with an alternate face, you can pass it in as the last parameter like this:local button = cel.button.new(100, 100, 'purplebutton'). When the button is created it will lookup a face with the name purplebutton. You can also pass a reference to the face directly like this:local button = cel.button.new(100, 100, purplebuttonface). In addition the name of a face is not restricted to a string, which is useful for creating private faces. TODO explain when face inheritance happens, not when it is created but wehn the metacel is created.

A cel is assigned a face when it is created.  A metacel will locate a suitable face using the metacel:getface(face) function, the face parameter can be either a face or its name.  In the following example both cels have the same face:

a = cel.new(20, 20, blueface)
b = cel.new(20, 20, 'blue')

Cel keeps a seperate index of faces per metacel.  For each face that is created it is indexed by itself and by its name, this is what allows you to specify either the name or the face itself when creating a cel. These are the steps in resolving the face when a cel is created:
If no face is specified the face of the creating metacel is used.
The face is looked up in the face index of the creating metacel, if found this is used.
The face is looked up in the face index of the cel metacel, if found this is used.  
The face is not a valid face for the creating metacel nor is it a named face for teh cel metacel.  In this case the face of the creating metacel is used.
Notice that named faces for the cel metacel are available to all types of cels, this is allowed because an every cel description will contain all the conent needed to render a normal cel.
events

How any gui library defines and implements events is probably the single most important feature it provides. If they are not well defined reacting to them reliably can be a challenge. One of the pimary design goals of Cel was to make event handling effortless and natural. This is harder than it sounds, (especially when balanced against encapsulation and sandboxing).  There are two types of events in Cel, synchronous and asynchonous.  An event is considered synchonous if the event handler is called when the event is generated, an asynchronous event is put in a fifo queue and the event handler is called when the event is taken off of the queue.  
The primary reason Cel uses asynchronous events is to allow the event handler to be unrestricted.  The onmousein event is a good example.  If onmousein were synchornous then there would have to be these restrictions on the hadler:

Do not mutate the cel tree - don't link, unlink, relink, move, resize, raise, sink etc.
Do not trap the mouse or change focus etc.
The reason for the restrictions is becuase the cel tree is walked as these events are generated.  These complications are all neatly solved by using asynchrnous events.  These basic cel events are asynchronous:
onresize
onmousemove
onmousein
oumouseout
onmousedown
onmouseup
onmousewheel
onkeydown
onkeypress
onkeyup
onchar
oncommand
ontimer
onfocus
There are other pros/cons for syncrounous vs asynchrnous events which I will not go into here.  A normal cel has no synchronous events, an event that is triggered by an asynchronous event should be synchronous in most cases.  A button defines these events which are all syncrhonous
onpress - triggered by onmousedown
onhold - triggered by ontimer
onclick - triggered by onmouseup
An event handler is just a normal function, the parameters to the function vary by event.  Define the function on the cel to act on the event:
local button = cel.button.new(20, 20)

function button:onresize(ow, oh)
  print('button resized', self, ow, oh)
end
When the button is resized the onresize function will be called when the event is taken off the event queue.  This approach is simple and the most common scenario.  Using the event listener approach is useful when multiple (decoupled) listeners need to recieve the event.  
local function acelresized(self, ow, oh)
  print('cel', self, 'resized', ow, oh, self.w, self.h)
end

button:addlistener('onresize', acelresized)
The listener approach is more cumbersome, and often unecessary, but it can be useful.  Both techniques can be used together, for a single event the event handlers are called in this order:
The metacels on[event] function
The cels on[event] function
The listener functions for on[event], the order in which these are called is not defined.
There is another order to events that is important to understand.  When an event applies to a cel and its host, for example onmousedown, it is always sent to the cel furthest down the cel tree first, then
up the cel tree to its host (known as event bubbling).  Cel does not allow a host cel to prevent its links from receiving events (known as event capturing), this is prevented to ensure that any type of cel can be linked to any other type of cel and still function.  Likewise a cel cannot terminate an event.  For events that bubble up the cel tree a flag is sent to the event hander indicating if the event was intercepted,  the handler may want to alter its behavior if the event was already intercepted.  To intercept an event, the event handler should return true.


