<html> 
 
<head> 
<title>About Cel</title> 
</head> 
 
<body>

  <h1>Introduction</h1>
  <p>A cel ([c]ontrol [el]ement) is the basic unit or building block of the Cel
  library. To use the libarry effectively you must understand what a cel is
  as well as what it can and can't do. A cel is the equivalent of a widget.  A cel aggregates
  user input events, and will normally be rendered to the screen.</p>

  <h2>the cel rectangle</h2>
  <p>A cel is a rectangle cel.x is the left of the rectangle, cel.y is the top,
  cel.w is the width and cel.h is the height. The orgin of a cels coordinate
  system is at the top left corner of the cel, x increases to the right and
  y increases down.  The right of a cel is cel.x + cel.w, and the bottom is
  cel.y + cel.h.  A cel contains all points where <code>x &gt;= 0</code> and 
  <code>x &lt; cel.w</code> and <code>y &gt;=0</code> and <code>y &lt; cel.h</code>.
  This set can be restricted but not increased.</p>

  <h2>hosts and links</h2>
  <p><em>All</em> cels are containers.  This means that any cel (with the exception of
  the root cel) can be put into any other cel.  Furthermore the 
  contaier/containee relationship is fully dynamic and can be changed easily.
  This heirarchy or cel tree starts with the root cel (obvious, i know).  
  Often this root cel would be called a parent, and the cels that it contains
  would be called its children.  This is not the terminology used by Cel 
  because parent/child implies that the parent creates the child and that
  the relationship is fixed.  To highlight that the relationship is mutable the
  parent is called the host and the child a link (because it is linked to the
  host).  When reading the documentation, up the cel tree means towards the
  root of the tree.  From here on out the terms host and link will be used.</p>

  <h2>composite cels</h2>
  <p>A composite cel is a cel that is composed from other cels.  The host cel is called the composite cel
  and any cels that are <em>created</em> by it are called component cels.  The created distinction is important, a
  cel that is linked to the composite cel is not considered a component cel if it was not created by the 
  composite cel.  Typically a composite cel will encapsulate its component cels.</p>

  <h2>Goals - the requirements that shaped the Cel library</h2>
  <p>Cels design is influenced by these requirements:

  <h3>Embeddability</h3>
  The prime requirement of Cel is it should be embeddable. Meaning embedding Cel in a host process that uses it and 
  controls it.  This implies that the requirements for a suitable host should be minimal.  This requirement is
  why Cel is passive, the host process always tells Cel when and how to act.  Cel also does not render anything,
  nor does it define a pattern for rendering, rendering is the job of the host process.

  <h3>Easy to use</h3>
  This is just a bit less important than the prime requirement.  Easy to use is the whole point of an api in the 
  first place (well at least for a high-level api like Cel).  
  My view is that there are endless ways to achieve the same result, an api is a path to that result.  Adding 
  features can make an api easier to use or harder to use, most of the time a feature will make some things easier
  and some harder.  Makeing those decisions is the art of api programming, there is no formula. 
  
  <p>Easy to use means different things depending on the type of user. Cel is targeted to three types of users:
  <ol>
    <li>
    The platform(like Love) programmer who has all the basic ingredients for a gui, such as mouse and keyboard 
    input, and rendering capabilites.  There are literrally hundreds of these platforms, each custom made and 
    lovingly crafted.  Many of them have primitive gui support (becuase its more work than it seems).  I want
    them all to use Cel, and I want Cel to be a natural fit for their platform so that they want to use it.  
    This means providing what they don't have, and not what they do, which is why Cel does not render.
    </li>  
    <li>
    The gui programmer.  This could be a programmer using a platform or the platform programmer.  If these guys
    don't like Cel, then the platform programmer will not want to offer it.  This programmer is the true test
    of the api, and most of the api design favors making this user happy, sometimes at the cost of the platform 
    programmer.
    </li>  
    <li>The user interacting with gui.  This means full featured controls, for example a scrollbar that works as
    expected, not a watered down shell of what we are all familiar with using.
    </li>
  </ol>
  </p>

  <h2>Speed</h2>
  <p>All of the requirements have priority over speed.  I'm not saying speed is not important, it is very 
  important but a high-level api is the antithesis of speed.  Speed is the easiest goal to achieve, simply 
  reduce features and/or write it in assembly.   The job of an api is to make good tradeoffs between execution
  speed and ease of use.  Obviously what ends up on the screen can be done another way with a different
  set of tradeoffs.

  <h2>Sandboxing</h2>
  <p>TODO</p>

  <h2>Derived Requirements</h2>
  <p>These requirements are aimed at making Cel easy to use without breaking the prime requirement of embedability.</p>

  <h3>No special cases</h3>
  <p>There should be no special cases or special cels that are allowed to break the rules.  Special cases really 
  just leads to special cases gone wild, which leads to ???, which leads to suffering.  
  This is an ideal, but alas the root cel is special becuase it cannot link or be unlinked.</p>

  <h3>Text metrics and display</h3>
  <p>Cel should have halfway decent text output, meaning support for basic font metrics.  Ideally it would just give you
  beautiful font rendering (becuase its not fun or easy to roll your own).  Unfortunately I could not achieve this
  becuase it would be a large hurdle to embedability.  Cel, instead, attempts to ease the burden of dealing with
  text.</p>

  <h3>Automatic layout</h3>
  <p>Automatic layout is a requirement, that I originally assumed would not be.  After all, what could be easier
  that settting x,y,width,height for a rectangle, right?  Well I tried that, then I tried to make a demo, and the
  simplest things (like a list of textbuttons equal width and height) were just too hard to do.  I had to make sure
  i knew the longest string I wanted to display and if those strings changed, i had to react someway.  This was 
  all part of the demo, I was adding automatic layout in the demo app itself to work around these problems.  This
  was one of those times I had to admit defeat and admit automatic layout is a requirement for 'easy to use'.</p>
  <p>I was not thrilled with automatic layout in any gui library I had used before, if the layout was flexible it
  wasn't easy, if it was easy it was not flexible.  Cel has automatic layout built into every cel, and you will
  use it without even realizeing it.</p>

  <h3>A mutable cel tree</h3>
  <p>The primary functions to enable this are cel:link() and cel:unlink().  If you have a cel, linking it to another
  cel is <em>always</em> ok, and 'just works', and the same goes for unlinking.  Having to manage when you can
  and cannot do this and what cels go with what other cels would be a nightmare, worse than memory management.  So Cel
  doesn't require that you do, and to enable this encapsulation is necessary.</p>

  <h3>Encapsulation</h3>
  <p>A cel has many properties that are not
  exposed outside of the core library, these are considered implementation 
  details in some cases, but it is mostly done so that things 'just work'.
  Any derived cel can use the same techniques that Cel uses to achieve encapsulation.
  </p>

  <p>The cel tree cannot be queried or walked.  This means there is no way to get the host
  of a cel or get the links of a cel.  <em>There is no method that exposes a cel that the
    application did not create.</em>  This 
  means there is no way to get the cel with focus, or under the mouse etc.
  You may think that it is too restrictive, but the effect is the opposite.  
  Putting a window in a listbox, or an editbox in a listbox or a label in a 
  listbox are all identical operations, and this is largely enabled by
  encapsulation.</p>

  <p>Cel doesn't actively enforce encapsulation, but it does enable it by not exposing cels. 
  Cel does not expose cels is becuase the cel tree is mutable (which is highly desireable). 
  Here is an partial list of intentionally ommited functionality:</p>
  <ul>
    <li><code>cel:gethost()</code></li>
    <li><code>cel:getlinks()</code></li>
    <li><code>cel.getcelwithfocus()</code></li>
    <li><code>cel.getcelatxy(x,y)</code></li>
    <li><code>cel.getbyid(id)</code></li>
  </ul>
    
  <p>
  <em>A composite cel should be able to assert full control of the layout and lifecycle of its component cels.</em>
  The ability to peek into or walk the cel tree means creating a composite cel is too hard, and the end result will
  be too fragile.  
  To illustrate the problem I'll use the window cel.  A window has a handle to drag the window around with, this 
  handle is actually another cel that the window encapsulates.  What can a window do to ensure that this cel is
  not unlinked?  One option would be to set a property on the cel and prevent unlinking if this property is set, 
  but that solution is a hack and would lead to uncertainty and an endless number of special cases.  If I as the 
  gui programmer unlink a cel, I expect it to happen, period.  Cel enables encapsulation so that you can hide cels you
  need full control of.  The functionality lost by this encapsulation is regained through the link() and relink()
  functions.  For example how does one add a button to the window handle, if you can't link to it?
  Enabling that type of functionality is what guided the desing of the link(), relink() and __link(). 
  How does one alter the properties of the handle, for instance its size, appearance, etc?
  Enabling that type of functionality is what <em>initially</em> guided the design of cel faces.</p>

  <h3>Separation of concerns</h3>
  <p>When creating a gui the look is very important.  Specifying the functionality of a cel, and how the app reacts
  to events is a concern that is largely orthogonal to how the cel looks.  Defining this separation is especially 
  important to Cel because it has no rendering capabilites.  Cel enables this separation through cel faces.  A face
  is the context available to the renderer and is associated to a cel at creation.  Besides seperating functionality 
  from appearance this has several other advantages.  

  <p>To illustrate I will show the bad, but not uncommon way this is done in many gui libraries. This is the bad way:
  <pre><code>
    button = cel.button.new(10, 10)
    button.setcolor('blue')
    button.setbordersize(2)
    button.setactivatecolor('green')
  </code></pre>
  Identifying a cel semantically is better:
  <pre><code>
    button = cel.button.new(10, 10, 'invetory button')
  </code></pre>
  </p>

  <ul>Why is the bad way bad?
    <li>The most common scenario is a bunch of buttons will look the same, they will have the same colors or images etc.
    Repeating this for each identical looking button is just noise.  This puts the burden on the app programmer to 
    create specialized generators, or overly long constructors to prevent repeating themselves.
    </li>
    <li>Its an unecessary waste of space, storing the same information for each button.  There is no workaround 
    to fix this issue.
    </li>
    <li>It ends up being too hard to change, and enforcing a common theme is an added task for the app programmer.</li>
    <li>It presents a barrier to simultaneous work, as in artist/programmer working independently</li>
  </ul>

  <p>
  The better way addresses all of these problems.  One recently popular way to do this is to copy html/css
  type of functionality.  There is certainly wisdom and good design happening there, but a gui does not occupy the
  same space as html, it doesn't have an abundance of content, and layout is often an integral part of the
  functionality of the gui.  Cel faces have some similarity to this model, but is targeted to the needs of a typical
  gui, not a document. </p>


  <h3>Reuse through inheritance</h3>
  <p>Composition inheritance has already been discussed, that is what a composite cel is.  Composition inheritance
  is best, but sometimes implementation inheritance is useful.  Cel does support implementation inheritance,
  but it should not be your first choice when creating a new type of cel. The main reason is that implementation
  inheritance is too fragile and some people view it as an is-a relationship which is only sometimes true.  A 
  hallmark of implementation inheritance is overriding existing methods, this is also where you will get into 
  trouble if you are not <em>very</em> careful.  Adding to the implementation without overriding is much less fragile, 
  but you can get that through composition.  So implementation inheritance is really only useful for overriding or
  indicating the is-a relationship (but overriding can turn the is-a relationship off imo).  To override a function
  or property(in a way the parent did not anticipate) using implementation inheritance requires knowledge of the
  internal workings of the parent.  It works well in a cohesive pacakge, or when you already have a full understanding
  of the parent implementation details.</p>

  <p>How can overriding change the is-a relationship you ask?  Well changing a defining characteristic will do it imo.
  A Cel label has the characteristic that it can't be touched, as if it is etched into its host cel.  If I overrode that
  behavior, and let it be touched the new cel is no longer a label, becuase it is not a drop in replacement for a label
  in every circumstance.  The built-in Cel controls do exactly this kind of overriding, do not make the assumption
  that the is-a relationship is true just because implementation inheritance is used.  The relationship will be
  stated in the documentation.  By convention is-a cel will be true for any type of cel.</p>

  <p>If implementation inheritance is so bad what does Cel use it?  The reason is because its useful, the code reuse
  is real, <em>and you can expose a private interface to the inheriting cel.</em>  Through alternate interface you can
  enable more dangerous but useful functions.  They can be more dangerous becuase there use can be segregated.  A cel
  could be created that does something wrong, that has erratic behavior, or crashes, etc.  Simple solution don't use it,  or maybe even fix it in that one place.  If these useful but dangerous functions were exposed to any instance of any
  cel the problem becomes much bigger.  What makes a function dangerous?  Well there is no formula for that, sorry.
  </p>

  <p>Cel takes a pragmatic approach to this.  Use the public interface and its easy going, use the private interface
  and you are trusted and take on a higher level of responsibility.  The private interface is a part of the metacel.
  The Cel documentation will instruct you on how it expects this interface to be used.  Deviating from those 
  expectaions is not advised.</p>

  <h2>metacels</h2>

  <h2>faces</h2>

  <h2>events</h2>
  <p>How any gui library defines and implements events is probably the single
  most important feature it provides.  If they are not well defined reacting
  to them reliably can be a challenge.  One of the pimary design goals of Cel
  was to make event handling effortless and natural.  This is harder than it
  sounds, (especially when balanced against encapsulation and sandboxing. </p>

  <h2>Why Lua</h2>
  <p>This is where I say how ridiculously awesome Lua is, coming soon</p>

  <h2>Areas for improvement</h2>
  <ul>
    <li>
    Creating a new type of cel (called a metacel) should be easy.  Its not as easy as I wanted it to be.
    </li>
    <li>
    Extending a cel (other than a basic cel) pretty much requires knowledge of what the original cel is doing, meaning
    reading the source.  I think this is a universal problem with implementation inheritance though,
    and I don't think I can do anything to really make it better.
    </li>
    <li>
    Cel has some global state (not global variables).  An example is Cel tracks all cel faces and does not enable
    strong encapsulation.  There is no reason it has to be this way and it will be fixed.  This also applies to 
    the list of predefined linker functions.  It's not a huge problem, mainly it makes sandboxing too hard.
    </li>
    <li>
    Cel is missing some type of controls, some of this will probably never be added because they are too trivial
    (a progress bar) or are a barrier to embedding (image support).
    </li>
    <li>
    Speed, overall profiling and optimization.
    </li>
  </ul>
</body>
</html>
