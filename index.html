<html> 
 
<head> 
<title>About Cel</title> 
</head> 
 
<body>

  <h1>Introduction</h1>
  <p>A cel ([c]ontrol [el]ement) is the basic unit or building block of the Cel
  library. To use the libarry effectively you must understand what a cel is
  as well as what it can and can't do.</p>

  <h2>History</h2>
  <p>
  
  <h2>the cel rectangle</h2>
  <p>A cel is a rectangle cel.x is the left of the rectangle, cel.y is the top,
  cel.w is the width and cel.h is the height. The orgin of a cels coordinate
  system is at the top left corner of the cel, x increases to the right and
  y increases down.  The right of a cel is cel.x + cel.w, and the bottom is
  cel.y + cel.h.  A cel contains all points where x &gt;= 0 and x &lt; cel.w 
  and y &gt;=0 and y &lt; cel.h.  This set can be restricted but not increased.</p>

  <h2>hosts and links</h2>
  <p>ALL cels are containers.  This means that any cel (with the exception of
  the root cel) can be put into any other cel.  Furthermore the 
  contaier/containee relationship is fully dynamic and can be changed easily.
  This heirarchy or cel tree starts with the root cel (obvious, i know).  
  Often this root cel would be called a parent, and the cels that it contains
  would be called its children.  Thi s is not the terminology used by Cel 
  because parent/child implies that the parent creates the child and that
  the relationship is fixed.  To highlight that the relationship is mutable the
  parent is called the host and the child a link (because it is linked to the
  host).  When reading the documentation, up the cel tree means towards the
  root of the tree.  From here on out the terms host and link will be used.</p>

  <h2>Goals - the requirements that shaped the Cel library</h2>
  <p>Cels design is influenced by these requirements:

  <h3>Embeddability</h3>
  The prime requirement of Cel is it should be embeddable. Meaning embedding Cel in a host process that uses it and 
  controls it.  This implies that the requirements for a suitable host should be minimal.  This requirement is
  why Cel is passive, the host process always tells Cel when and how to act.  Cel also does not render anything,
  nor does it define a pattern for rendering, rendering is the job of the host process.

  <h3>Easy to use</h3>
  This is just a hair less important than the prime requirement.  Easy to use is the whole point of an api in the 
  place.  My view is that there are endless ways to achieve the same result, an api is a path to that result.  Adding 
  features can make an api easier to use or harder to use, most of the time a feature will make some things easier
  and some harder.  Makeing those decisions is the art of api programming, there is no formula. 
  
  <br>Cel is targeted to three types of users:
  <ol>
    <li>The user interacting with gui.  This means full featured controls, for example a scrollbar that works as
    expected, not a watered down shell of what we are all familiar with using.
    </li>
    <li>
    The platform(like Love) programmer who has all the basic ingredients for a gui, such as mouse and keyboard 
    input, and rendering capabilites.  There are literrally hundreds of these platforms, each custom made and 
    lovingly crafted.  Many of them have primitive gui support (becuase its more work than it seems).  I want
    them all to use Cel, and I want Cel to be a natural fit for their platform so that they want to use it.  
    This means providing what they don't have, and not what they do, which is why Cel does not render.
    </li>  
    <li>
    The gui programmer.  This could be a programmer using a platform or the platform programmer.  If these guys
    don't like Cel, then the platform programmer will not want to offer it.  This programmer is the true test
    of the api, and most of the api design favors making this user happy, sometimes at the cost of the other 
    types of users.
    </li>  
  </ol>
  </p>

  <h2>Sandboxing</h2>
  <p>TODO</p>

  <h2>Derived Requirements</h2>
  <p>These requirements are aimed at making Cel easy to use without breaking the prime requirement of embedability.</p>

  <h3>No special cases</h3>
  <p>There should be no special cases or special cels that are allowed to break the rules.  Special cases really 
  just leads to special cases gone wild, which leads to ???, which leads to suffering.  
  This is an ideal, but alas the root cel is special becuase it cannot link or be unlinked.</p>

  <h3>Text metrics and display</h3>
  <p>Cel should have halfway decent text output, meaning support basic font metrics.  Ideally it would just give you
  beautiful font rendering (becuase its not fun or easy to roll your own).  Unfortunately I could not achieve this
  becuase it would be a large hurdle to embedability.  Cel, instead, attempts to ease the burden of dealing with
  text.</p>

  <h3>Automatic layout</h3>
  <p>Automatic layout is a requirement, that I originally assumed would not be.  After all, what could be easier
  that settting x,y,width,height for a rectangle, right?  Well I tried that, then I tried to make a demo, and the
  simplest things (like a list of textbuttons equal width and height) were just too hard to do.  I had to make sure
  i knew the longest string I wanted to display and if those strings changed, i had to react someway.  This was 
  all part of the demo, I was adding automatic layout in the demo app itself to work around these problems.  This
  was one of those times I had to admit defeat and admit automatic layout is a requirement for 'easy to use'.</p>
  <p>I was not thrilled with automatic layout in any gui library I had used before, if the layout was flexible it
  wasn't easy, if it was easy it was not flexible.  Cel has automatic layout built into every cel, and you will
  use it without even realizeing it.</p>

  <h3>A mutable cel tree</h3>
  <p>The primary functions to enable this are cel:link() and cel:unlink().  If you have a cel, linking it to another
  cel is <em>always</em> ok, and 'just works', and the same goes for unlinking.  Having to manage when you can
  and cannot do this and what cels go with what other cels would be a nightmare, worse than memory management.  So Cel
  doesn't require that you do, and to enable this encapsulation is necessary.</p>

  <h3>Encapsulation</h3>
  <p>A cel has many properties that are not
  exposed outside of the core library, these are considered implementation 
  details in some cases, but it is mostly done so that things 'just work'.</p>

  <p>The cel
  tree cannot be queried or walked.  This means there is no way to get the host
  of a cel or get the links of a cel.  There is no method that exposes a cel that the
  application did not create.  This 
  means there is no way to get the cel with focus, or under the mouse etc.
  You may think that it is too restrictive, but the effect is the opposite.  
  Putting a window in a listbox, or an editbox in a listbox or a label in a 
  listbox are all identical operations, and this is largely enabled by
  encapsulation.</p>

  <p>Cel doesn't actively enforce encapsulation, but it does enable it by not exposing cels.  The idea is if you don't
  have a reference to a cel, you can't get it.  Here is an incomplete list of intentionally ommited functionality:
  <ul>
    <li><code>cel:gethost()</code></li>
    <li><code>cel:getlinks()</code></li>
    <li><code>cel.getcelwithfocus()</code></li>
    <li><code>cel.getcelatxy(x,y)</code></li>
    <li><code>cel.getbyid(id)</code></li>
  </ul>
  The reason this are absent is becuase the cel tree is mutable, which is highly desireable.  
  </p><p>
  <em>A composite cel should be able to assert full control of the layout and lifecycle of its component cels.</em>
  The ability to peek into or walk the cel tree means creating a composite cel is too hard, and the end result will
  be too fragile.  
  To illustrate the problem I'll use the window cel.  A window has a handle to drag the window around with, this 
  handle is actually another cel that the window encapsulates.  What can a window do to ensure that this cel is
  not unlinked?  One option would be to set a property on the cel and prevent unlinking if this property is set, 
  but that solution is a hack and would lead to uncertainty and an endless number of special cases.  If I as the 
  gui programmer unlink a cel, i expect it to happen, period.  That is why Cel enables encapsulation instead.  The 
  functionality lost by this encapsulation is regained through the link() and relink() functions.  For example how
  does one add a button to the window handle, if you can't link to it?  Enabling that type of functionality is what
  guided the desing of the link(), relink() and __link().  How does one alter the properties of the handle, for 
  instance its size, appearance, etc?  Enabling that type of functionality is what <em>initially</em> guided the
  design of cel faces.</p>

  <h3>Areas for improvement</h3>
  <ul>
    <li>
    Creating a new type of cel (called a metacel) should be easy.  Its not as easy as I wanted it to be.
    </li>
    <li>
    Extending a cel (other than a basic cel) pretty much requires knowledge of what the original cel is doing, meaning
    reading the source.  I think this is a universal problem with inheritance though, and I don't think I can do
    anything to really make it better.
    </li>
    <li>
    Cel has some global state (not global variables).  An example is Cel tracks all cel faces and does not enable
    strong encapsulation.  There is no reason it has to be this way and it will be fixed.  This also applies to 
    the list of predefined linker functions.  It's not a huge problem, mainly it makes sandboxing too hard.
    </li>
    <li>
    Cel is missing some type of controls, some of this will probably never be added because they are too trivial
    (a progress bar) or are a barrier to embedding (image support).
    </li>
    <li>
    TODO add more
    </li>
  </ul>

  
  <h2>Speed</h2>
  <p>All of the requirements have priority over speed.  Speed is the easiest goal to achieve, simply reduce
    features and/or write it in assembly.  I'm not saying speed is not important, it is very important but an api
    is the antithesis of speed. The job of an api is to make good tradeoffs between execution speed and ease
    of use.  Obviously what ends up on the screen can be done another way with a different set of tradeoffs.
  

  
  
  

  <h2>events</h2>
  <p>How any gui library defines and implements events is probably the single
  most important feature it provides.  If they are not well defined reacting
  to them reliably can be a challenge.  One of the pimary design goals of Cel
  was to make event handling effortless and natural.  This is harder than it
  sounds, (especially when balanced against encapsulation and sandboxing. </p>
</body>
</html>
